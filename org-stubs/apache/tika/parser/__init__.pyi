
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.net
import java.nio
import java.nio.file
import java.security
import java.util
import java.util.concurrent
import java.util.concurrent.atomic
import jpype
import jpype.protocol
import org.apache.tika.config
import org.apache.tika.detect
import org.apache.tika.extractor
import org.apache.tika.metadata
import org.apache.tika.metadata.writefilter
import org.apache.tika.mime
import org.apache.tika.parser.apple
import org.apache.tika.parser.asm
import org.apache.tika.parser.audio
import org.apache.tika.parser.code
import org.apache.tika.parser.crypto
import org.apache.tika.parser.csv
import org.apache.tika.parser.dbf
import org.apache.tika.parser.dgn
import org.apache.tika.parser.dif
import org.apache.tika.parser.digest
import org.apache.tika.parser.digestutils
import org.apache.tika.parser.dwg
import org.apache.tika.parser.epub
import org.apache.tika.parser.executable
import org.apache.tika.parser.external
import org.apache.tika.parser.external2
import org.apache.tika.parser.feed
import org.apache.tika.parser.font
import org.apache.tika.parser.html
import org.apache.tika.parser.http
import org.apache.tika.parser.hwp
import org.apache.tika.parser.image
import org.apache.tika.parser.indesign
import org.apache.tika.parser.iptc
import org.apache.tika.parser.iwork
import org.apache.tika.parser.mail
import org.apache.tika.parser.mailcommons
import org.apache.tika.parser.mat
import org.apache.tika.parser.mbox
import org.apache.tika.parser.microsoft
import org.apache.tika.parser.mif
import org.apache.tika.parser.mp3
import org.apache.tika.parser.mp4
import org.apache.tika.parser.multiple
import org.apache.tika.parser.ocr
import org.apache.tika.parser.odf
import org.apache.tika.parser.pdf
import org.apache.tika.parser.pkg
import org.apache.tika.parser.prt
import org.apache.tika.parser.sas
import org.apache.tika.parser.strings
import org.apache.tika.parser.tmx
import org.apache.tika.parser.txt
import org.apache.tika.parser.video
import org.apache.tika.parser.wacz
import org.apache.tika.parser.warc
import org.apache.tika.parser.wordperfect
import org.apache.tika.parser.xliff
import org.apache.tika.parser.xml
import org.apache.tika.parser.xmp
import org.apache.tika.renderer
import org.apache.tika.sax
import org.w3c.dom
import org.xml.sax
import typing



class AutoDetectParserConfig(org.apache.tika.config.ConfigBase, java.io.Serializable):
    DEFAULT: typing.ClassVar['AutoDetectParserConfig'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int, long2: int, long3: int, integer: int, integer2: int): ...
    def getContentHandlerDecoratorFactory(self) -> org.apache.tika.sax.ContentHandlerDecoratorFactory: ...
    def getDigesterFactory(self) -> 'DigestingParser.DigesterFactory': ...
    def getEmbeddedDocumentExtractorFactory(self) -> org.apache.tika.extractor.EmbeddedDocumentExtractorFactory: ...
    def getMaximumCompressionRatio(self) -> int: ...
    def getMaximumDepth(self) -> int: ...
    def getMaximumPackageEntryDepth(self) -> int: ...
    def getMetadataWriteFilterFactory(self) -> org.apache.tika.metadata.writefilter.MetadataWriteFilterFactory: ...
    def getOutputThreshold(self) -> int: ...
    def getSpoolToDisk(self) -> int: ...
    def getThrowOnZeroBytes(self) -> bool: ...
    @staticmethod
    def load(element: org.w3c.dom.Element) -> 'AutoDetectParserConfig': ...
    def setContentHandlerDecoratorFactory(self, contentHandlerDecoratorFactory: typing.Union[org.apache.tika.sax.ContentHandlerDecoratorFactory, typing.Callable]) -> None: ...
    def setDigesterFactory(self, digesterFactory: 'DigestingParser.DigesterFactory') -> None: ...
    def setEmbeddedDocumentExtractorFactory(self, embeddedDocumentExtractorFactory: typing.Union[org.apache.tika.extractor.EmbeddedDocumentExtractorFactory, typing.Callable]) -> None: ...
    def setMaximumCompressionRatio(self, long: int) -> None: ...
    def setMaximumDepth(self, int: int) -> None: ...
    def setMaximumPackageEntryDepth(self, int: int) -> None: ...
    def setMetadataWriteFilterFactory(self, metadataWriteFilterFactory: typing.Union[org.apache.tika.metadata.writefilter.MetadataWriteFilterFactory, typing.Callable]) -> None: ...
    def setOutputThreshold(self, long: int) -> None: ...
    def setSpoolToDisk(self, long: int) -> None: ...
    def setThrowOnZeroBytes(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...

class ParseContext(java.io.Serializable):
    def __init__(self): ...
    def equals(self, object: typing.Any) -> bool: ...
    _get_0__T = typing.TypeVar('_get_0__T')  # <T>
    _get_1__T = typing.TypeVar('_get_1__T')  # <T>
    @typing.overload
    def get(self, class_: typing.Type[_get_0__T]) -> _get_0__T: ...
    @typing.overload
    def get(self, class_: typing.Type[_get_1__T], t: _get_1__T) -> _get_1__T: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[str]: ...
    _set__T = typing.TypeVar('_set__T')  # <T>
    def set(self, class_: typing.Type[_set__T], t: _set__T) -> None: ...

class ParseRecord:
    def __init__(self): ...
    def addException(self, exception: java.lang.Exception) -> None: ...
    def addMetadata(self, metadata: org.apache.tika.metadata.Metadata) -> None: ...
    def addWarning(self, string: str) -> None: ...
    def getDepth(self) -> int: ...
    def getExceptions(self) -> java.util.List[java.lang.Exception]: ...
    def getMetadataList(self) -> java.util.List[org.apache.tika.metadata.Metadata]: ...
    def getParsers(self) -> typing.MutableSequence[str]: ...
    def getWarnings(self) -> java.util.List[str]: ...
    def isWriteLimitReached(self) -> bool: ...
    def setWriteLimitReached(self, boolean: bool) -> None: ...

class Parser(java.io.Serializable):
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class ParserFactory:
    def __init__(self, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]]): ...
    def build(self) -> Parser: ...

class ParsingReader(java.io.Reader):
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, string: str): ...
    @typing.overload
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, parser: Parser, inputStream: java.io.InputStream, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext): ...
    @typing.overload
    def __init__(self, parser: Parser, inputStream: java.io.InputStream, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext, executor: typing.Union[java.util.concurrent.Executor, typing.Callable]): ...
    def close(self) -> None: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, charArray: typing.Union[typing.List[str], jpype.JArray]) -> int: ...
    @typing.overload
    def read(self, charBuffer: java.nio.CharBuffer) -> int: ...
    @typing.overload
    def read(self, charArray: typing.Union[typing.List[str], jpype.JArray], int: int, int2: int) -> int: ...

class PasswordProvider:
    def getPassword(self, metadata: org.apache.tika.metadata.Metadata) -> str: ...

class RenderingParser:
    def setRenderer(self, renderer: org.apache.tika.renderer.Renderer) -> None: ...

class AbstractEncodingDetectorParser(Parser):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, encodingDetector: typing.Union[org.apache.tika.detect.EncodingDetector, typing.Callable]): ...
    def getEncodingDetector(self) -> org.apache.tika.detect.EncodingDetector: ...
    def setEncodingDetector(self, encodingDetector: typing.Union[org.apache.tika.detect.EncodingDetector, typing.Callable]) -> None: ...

class AbstractExternalProcessParser(Parser):
    def __init__(self): ...

class AbstractParser(Parser):
    def __init__(self): ...
    @typing.overload
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    @typing.overload
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata) -> None: ...

class AutoDetectParserFactory(ParserFactory):
    TIKA_CONFIG_PATH: typing.ClassVar[str] = ...
    def __init__(self, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]]): ...
    def build(self) -> Parser: ...

class CompositeParser(Parser):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, list: java.util.List[Parser]): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, list: java.util.List[Parser], collection: typing.Union[java.util.Collection[typing.Type[Parser]], typing.Sequence[typing.Type[Parser]], typing.Set[typing.Type[Parser]]]): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, *parser: Parser): ...
    def findDuplicateParsers(self, parseContext: ParseContext) -> java.util.Map[org.apache.tika.mime.MediaType, java.util.List[Parser]]: ...
    def getAllComponentParsers(self) -> java.util.List[Parser]: ...
    def getFallback(self) -> Parser: ...
    def getMediaTypeRegistry(self) -> org.apache.tika.mime.MediaTypeRegistry: ...
    @typing.overload
    def getParsers(self) -> java.util.Map[org.apache.tika.mime.MediaType, Parser]: ...
    @typing.overload
    def getParsers(self, parseContext: ParseContext) -> java.util.Map[org.apache.tika.mime.MediaType, Parser]: ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    def setFallback(self, parser: Parser) -> None: ...
    def setMediaTypeRegistry(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry) -> None: ...
    def setParsers(self, map: typing.Union[java.util.Map[org.apache.tika.mime.MediaType, Parser], typing.Mapping[org.apache.tika.mime.MediaType, Parser]]) -> None: ...

class DelegatingParser(Parser):
    def __init__(self): ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class EmptyParser(Parser):
    INSTANCE: typing.ClassVar['EmptyParser'] = ...
    def __init__(self): ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class ErrorParser(Parser):
    INSTANCE: typing.ClassVar['ErrorParser'] = ...
    def __init__(self): ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class NetworkParser(Parser):
    @typing.overload
    def __init__(self, uRI: java.net.URI): ...
    @typing.overload
    def __init__(self, uRI: java.net.URI, set: java.util.Set[org.apache.tika.mime.MediaType]): ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class ParserDecorator(Parser):
    def __init__(self, parser: Parser): ...
    def getDecorationName(self) -> str: ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def getWrappedParser(self) -> Parser: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    @staticmethod
    def withFallbacks(collection: typing.Union[java.util.Collection[Parser], typing.Sequence[Parser], typing.Set[Parser]], set: java.util.Set[org.apache.tika.mime.MediaType]) -> Parser: ...
    @staticmethod
    def withTypes(parser: Parser, set: java.util.Set[org.apache.tika.mime.MediaType]) -> Parser: ...
    @staticmethod
    def withoutTypes(parser: Parser, set: java.util.Set[org.apache.tika.mime.MediaType]) -> Parser: ...

class RegexCaptureParser(Parser, org.apache.tika.config.Initializable):
    def __init__(self): ...
    def checkInitialization(self, initializableProblemHandler: typing.Union[org.apache.tika.config.InitializableProblemHandler, typing.Callable]) -> None: ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def initialize(self, map: typing.Union[java.util.Map[str, org.apache.tika.config.Param], typing.Mapping[str, org.apache.tika.config.Param]]) -> None: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    def setCaptureMap(self, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]]) -> None: ...
    def setMatchMap(self, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]]) -> None: ...
    def setWriteContent(self, boolean: bool) -> None: ...

class AutoDetectParser(CompositeParser):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, tikaConfig: org.apache.tika.config.TikaConfig): ...
    @typing.overload
    def __init__(self, detector: typing.Union[org.apache.tika.detect.Detector, typing.Callable]): ...
    @typing.overload
    def __init__(self, detector: typing.Union[org.apache.tika.detect.Detector, typing.Callable], *parser: Parser): ...
    @typing.overload
    def __init__(self, *parser: Parser): ...
    def getAutoDetectParserConfig(self) -> AutoDetectParserConfig: ...
    def getDetector(self) -> org.apache.tika.detect.Detector: ...
    @typing.overload
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata) -> None: ...
    @typing.overload
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    def setAutoDetectParserConfig(self, autoDetectParserConfig: AutoDetectParserConfig) -> None: ...
    def setDetector(self, detector: typing.Union[org.apache.tika.detect.Detector, typing.Callable]) -> None: ...

class CryptoParser(DelegatingParser):
    @typing.overload
    def __init__(self, string: str, provider: java.security.Provider, set: java.util.Set[org.apache.tika.mime.MediaType]): ...
    @typing.overload
    def __init__(self, string: str, set: java.util.Set[org.apache.tika.mime.MediaType]): ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class DefaultParser(CompositeParser):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, serviceLoader: org.apache.tika.config.ServiceLoader): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, serviceLoader: org.apache.tika.config.ServiceLoader, collection: typing.Union[java.util.Collection[typing.Type[Parser]], typing.Sequence[typing.Type[Parser]], typing.Set[typing.Type[Parser]]]): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, serviceLoader: org.apache.tika.config.ServiceLoader, collection: typing.Union[java.util.Collection[typing.Type[Parser]], typing.Sequence[typing.Type[Parser]], typing.Set[typing.Type[Parser]]], encodingDetector: typing.Union[org.apache.tika.detect.EncodingDetector, typing.Callable], renderer: org.apache.tika.renderer.Renderer): ...
    @typing.overload
    def __init__(self, mediaTypeRegistry: org.apache.tika.mime.MediaTypeRegistry, serviceLoader: org.apache.tika.config.ServiceLoader, encodingDetector: typing.Union[org.apache.tika.detect.EncodingDetector, typing.Callable], renderer: org.apache.tika.renderer.Renderer): ...
    def getAllComponentParsers(self) -> java.util.List[Parser]: ...
    @typing.overload
    def getParsers(self) -> java.util.Map[org.apache.tika.mime.MediaType, Parser]: ...
    @typing.overload
    def getParsers(self, parseContext: ParseContext) -> java.util.Map[org.apache.tika.mime.MediaType, Parser]: ...

class DigestingParser(ParserDecorator):
    def __init__(self, parser: Parser, digester: typing.Union['DigestingParser.Digester', typing.Callable], boolean: bool): ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    class Digester:
        def digest(self, inputStream: java.io.InputStream, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...
    class DigesterFactory:
        def build(self) -> 'DigestingParser.Digester': ...
        def isSkipContainerDocument(self) -> bool: ...
        def setSkipContainerDocument(self, boolean: bool) -> None: ...
    class Encoder:
        def encode(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> str: ...

class ParserPostProcessor(ParserDecorator):
    def __init__(self, parser: Parser): ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class RecursiveParserWrapper(ParserDecorator):
    @typing.overload
    def __init__(self, parser: Parser): ...
    @typing.overload
    def __init__(self, parser: Parser, boolean: bool): ...
    @staticmethod
    def getResourceName(metadata: org.apache.tika.metadata.Metadata, atomicInteger: java.util.concurrent.atomic.AtomicInteger) -> str: ...
    def getSupportedTypes(self, parseContext: ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: ParseContext) -> None: ...

class StatefulParser(ParserDecorator):
    def __init__(self, parser: Parser): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.parser")``.

    AbstractEncodingDetectorParser: typing.Type[AbstractEncodingDetectorParser]
    AbstractExternalProcessParser: typing.Type[AbstractExternalProcessParser]
    AbstractParser: typing.Type[AbstractParser]
    AutoDetectParser: typing.Type[AutoDetectParser]
    AutoDetectParserConfig: typing.Type[AutoDetectParserConfig]
    AutoDetectParserFactory: typing.Type[AutoDetectParserFactory]
    CompositeParser: typing.Type[CompositeParser]
    CryptoParser: typing.Type[CryptoParser]
    DefaultParser: typing.Type[DefaultParser]
    DelegatingParser: typing.Type[DelegatingParser]
    DigestingParser: typing.Type[DigestingParser]
    EmptyParser: typing.Type[EmptyParser]
    ErrorParser: typing.Type[ErrorParser]
    NetworkParser: typing.Type[NetworkParser]
    ParseContext: typing.Type[ParseContext]
    ParseRecord: typing.Type[ParseRecord]
    Parser: typing.Type[Parser]
    ParserDecorator: typing.Type[ParserDecorator]
    ParserFactory: typing.Type[ParserFactory]
    ParserPostProcessor: typing.Type[ParserPostProcessor]
    ParsingReader: typing.Type[ParsingReader]
    PasswordProvider: typing.Type[PasswordProvider]
    RecursiveParserWrapper: typing.Type[RecursiveParserWrapper]
    RegexCaptureParser: typing.Type[RegexCaptureParser]
    RenderingParser: typing.Type[RenderingParser]
    StatefulParser: typing.Type[StatefulParser]
    apple: org.apache.tika.parser.apple.__module_protocol__
    asm: org.apache.tika.parser.asm.__module_protocol__
    audio: org.apache.tika.parser.audio.__module_protocol__
    code: org.apache.tika.parser.code.__module_protocol__
    crypto: org.apache.tika.parser.crypto.__module_protocol__
    csv: org.apache.tika.parser.csv.__module_protocol__
    dbf: org.apache.tika.parser.dbf.__module_protocol__
    dgn: org.apache.tika.parser.dgn.__module_protocol__
    dif: org.apache.tika.parser.dif.__module_protocol__
    digest: org.apache.tika.parser.digest.__module_protocol__
    digestutils: org.apache.tika.parser.digestutils.__module_protocol__
    dwg: org.apache.tika.parser.dwg.__module_protocol__
    epub: org.apache.tika.parser.epub.__module_protocol__
    executable: org.apache.tika.parser.executable.__module_protocol__
    external: org.apache.tika.parser.external.__module_protocol__
    external2: org.apache.tika.parser.external2.__module_protocol__
    feed: org.apache.tika.parser.feed.__module_protocol__
    font: org.apache.tika.parser.font.__module_protocol__
    html: org.apache.tika.parser.html.__module_protocol__
    http: org.apache.tika.parser.http.__module_protocol__
    hwp: org.apache.tika.parser.hwp.__module_protocol__
    image: org.apache.tika.parser.image.__module_protocol__
    indesign: org.apache.tika.parser.indesign.__module_protocol__
    iptc: org.apache.tika.parser.iptc.__module_protocol__
    iwork: org.apache.tika.parser.iwork.__module_protocol__
    mail: org.apache.tika.parser.mail.__module_protocol__
    mailcommons: org.apache.tika.parser.mailcommons.__module_protocol__
    mat: org.apache.tika.parser.mat.__module_protocol__
    mbox: org.apache.tika.parser.mbox.__module_protocol__
    microsoft: org.apache.tika.parser.microsoft.__module_protocol__
    mif: org.apache.tika.parser.mif.__module_protocol__
    mp3: org.apache.tika.parser.mp3.__module_protocol__
    mp4: org.apache.tika.parser.mp4.__module_protocol__
    multiple: org.apache.tika.parser.multiple.__module_protocol__
    ocr: org.apache.tika.parser.ocr.__module_protocol__
    odf: org.apache.tika.parser.odf.__module_protocol__
    pdf: org.apache.tika.parser.pdf.__module_protocol__
    pkg: org.apache.tika.parser.pkg.__module_protocol__
    prt: org.apache.tika.parser.prt.__module_protocol__
    sas: org.apache.tika.parser.sas.__module_protocol__
    strings: org.apache.tika.parser.strings.__module_protocol__
    tmx: org.apache.tika.parser.tmx.__module_protocol__
    txt: org.apache.tika.parser.txt.__module_protocol__
    video: org.apache.tika.parser.video.__module_protocol__
    wacz: org.apache.tika.parser.wacz.__module_protocol__
    warc: org.apache.tika.parser.warc.__module_protocol__
    wordperfect: org.apache.tika.parser.wordperfect.__module_protocol__
    xliff: org.apache.tika.parser.xliff.__module_protocol__
    xml: org.apache.tika.parser.xml.__module_protocol__
    xmp: org.apache.tika.parser.xmp.__module_protocol__
