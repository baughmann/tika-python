
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.nio.file
import java.time
import java.util
import java.util.concurrent
import jpype.protocol
import org.apache.tika.pipes
import org.apache.tika.pipes.emitter
import org.apache.tika.pipes.pipesiterator
import typing



class AsyncConfig(org.apache.tika.pipes.PipesConfigBase):
    def __init__(self): ...
    def getEmitMaxEstimatedBytes(self) -> int: ...
    def getEmitWithinMillis(self) -> int: ...
    def getNumEmitters(self) -> int: ...
    def getPipesReporter(self) -> org.apache.tika.pipes.PipesReporter: ...
    def getQueueSize(self) -> int: ...
    def isEmitIntermediateResults(self) -> bool: ...
    @staticmethod
    def load(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]) -> 'AsyncConfig': ...
    def setEmitIntermediateResults(self, boolean: bool) -> None: ...
    def setEmitMaxEstimatedBytes(self, long: int) -> None: ...
    def setEmitWithinMillis(self, long: int) -> None: ...
    def setNumEmitters(self, int: int) -> None: ...
    def setPipesReporter(self, pipesReporter: org.apache.tika.pipes.PipesReporter) -> None: ...
    def setQueueSize(self, int: int) -> None: ...

class AsyncEmitter(java.util.concurrent.Callable[int]):
    def __init__(self, asyncConfig: AsyncConfig, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.pipes.emitter.EmitData], emitterManager: org.apache.tika.pipes.emitter.EmitterManager): ...
    def call(self) -> int: ...

class AsyncProcessor(java.io.Closeable):
    @typing.overload
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], pipesIterator: org.apache.tika.pipes.pipesiterator.PipesIterator): ...
    def checkActive(self) -> bool: ...
    def close(self) -> None: ...
    def finished(self) -> None: ...
    def getCapacity(self) -> int: ...
    def getTotalProcessed(self) -> int: ...
    @typing.overload
    def offer(self, list: java.util.List[org.apache.tika.pipes.FetchEmitTuple], long: int) -> bool: ...
    @typing.overload
    def offer(self, fetchEmitTuple: org.apache.tika.pipes.FetchEmitTuple, long: int) -> bool: ...

class AsyncStatus:
    def __init__(self): ...
    def getAsyncStatus(self) -> 'AsyncStatus.ASYNC_STATUS': ...
    def getCrashMessage(self) -> str: ...
    def getLastUpdate(self) -> java.time.Instant: ...
    def getStarted(self) -> java.time.Instant: ...
    def getStatusCounts(self) -> java.util.Map[org.apache.tika.pipes.PipesResult.STATUS, int]: ...
    def getTotalCountResult(self) -> org.apache.tika.pipes.pipesiterator.TotalCountResult: ...
    def toString(self) -> str: ...
    def update(self, map: typing.Union[java.util.Map[org.apache.tika.pipes.PipesResult.STATUS, int], typing.Mapping[org.apache.tika.pipes.PipesResult.STATUS, int]], totalCountResult: org.apache.tika.pipes.pipesiterator.TotalCountResult, aSYNC_STATUS: 'AsyncStatus.ASYNC_STATUS') -> None: ...
    def updateCrash(self, string: str) -> None: ...
    class ASYNC_STATUS(java.lang.Enum['AsyncStatus.ASYNC_STATUS']):
        STARTED: typing.ClassVar['AsyncStatus.ASYNC_STATUS'] = ...
        COMPLETED: typing.ClassVar['AsyncStatus.ASYNC_STATUS'] = ...
        CRASHED: typing.ClassVar['AsyncStatus.ASYNC_STATUS'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'AsyncStatus.ASYNC_STATUS': ...
        @staticmethod
        def values() -> typing.MutableSequence['AsyncStatus.ASYNC_STATUS']: ...

class OfferLargerThanQueueSize(java.lang.IllegalArgumentException):
    def __init__(self, int: int, int2: int): ...
    def getMessage(self) -> str: ...
    def getQueueSize(self) -> int: ...
    def getSizeOffered(self) -> int: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.pipes.async_")``.

    AsyncConfig: typing.Type[AsyncConfig]
    AsyncEmitter: typing.Type[AsyncEmitter]
    AsyncProcessor: typing.Type[AsyncProcessor]
    AsyncStatus: typing.Type[AsyncStatus]
    OfferLargerThanQueueSize: typing.Type[OfferLargerThanQueueSize]
