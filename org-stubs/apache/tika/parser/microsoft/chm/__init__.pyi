
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.math
import java.util
import jpype
import org.apache.tika.exception
import org.apache.tika.metadata
import org.apache.tika.mime
import org.apache.tika.parser
import org.xml.sax
import typing



_ChmAccessor__T = typing.TypeVar('_ChmAccessor__T')  # <T>
class ChmAccessor(java.io.Serializable, typing.Generic[_ChmAccessor__T]):
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], t: _ChmAccessor__T) -> None: ...

class ChmAssert:
    def __init__(self): ...
    @staticmethod
    def assertByteArrayNotNull(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    @staticmethod
    def assertChmAccessorNotNull(chmAccessor: typing.Union[ChmAccessor[typing.Any], typing.Callable[[typing.MutableSequence[int], typing.Any], None]]) -> None: ...
    @staticmethod
    def assertChmAccessorParameters(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmAccessor: typing.Union[ChmAccessor[typing.Any], typing.Callable[[typing.MutableSequence[int], typing.Any], None]], int: int) -> None: ...
    @staticmethod
    def assertChmBlockSegment(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmLzxcResetTable: 'ChmLzxcResetTable', int: int, int2: int, int3: int) -> None: ...
    @staticmethod
    def assertCopyingDataIndex(int: int, int2: int) -> None: ...
    @staticmethod
    def assertDirectoryListingEntry(int: int, string: str, entryType: 'ChmCommons.EntryType', int2: int, int3: int) -> None: ...
    @staticmethod
    def assertInputStreamNotNull(inputStream: java.io.InputStream) -> None: ...
    @staticmethod
    def assertPositiveInt(int: int) -> None: ...

class ChmBlockInfo:
    @typing.overload
    @staticmethod
    def getChmBlockInfoInstance(directoryListingEntry: 'DirectoryListingEntry', int: int, chmLzxcControlData: 'ChmLzxcControlData') -> 'ChmBlockInfo': ...
    @typing.overload
    @staticmethod
    def getChmBlockInfoInstance(directoryListingEntry: 'DirectoryListingEntry', int: int, chmLzxcControlData: 'ChmLzxcControlData', chmBlockInfo: 'ChmBlockInfo') -> 'ChmBlockInfo': ...
    def getEndBlock(self) -> int: ...
    def getEndOffset(self) -> int: ...
    def getIniBlock(self) -> int: ...
    def getStartBlock(self) -> int: ...
    def getStartOffset(self) -> int: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def toString(self) -> str: ...

class ChmCommons:
    UNDEFINED: typing.ClassVar[int] = ...
    VERBATIM: typing.ClassVar[int] = ...
    ALIGNED_OFFSET: typing.ClassVar[int] = ...
    UNCOMPRESSED: typing.ClassVar[int] = ...
    @staticmethod
    def assertByteArrayNotNull(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    @staticmethod
    def copyOfRange(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> typing.MutableSequence[int]: ...
    @staticmethod
    def getChmBlockSegment(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmLzxcResetTable: 'ChmLzxcResetTable', int: int, int2: int, int3: int) -> typing.MutableSequence[int]: ...
    @staticmethod
    def getLanguage(long: int) -> str: ...
    @staticmethod
    def getWindowSize(int: int) -> int: ...
    @staticmethod
    def hasSkip(directoryListingEntry: 'DirectoryListingEntry') -> bool: ...
    @typing.overload
    @staticmethod
    def indexOfDataSpaceStorageElement(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], byteArray2: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...
    @typing.overload
    @staticmethod
    def indexOfDataSpaceStorageElement(list: java.util.List['DirectoryListingEntry'], string: str) -> int: ...
    @staticmethod
    def indexOfResetTableBlock(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], byteArray2: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...
    @staticmethod
    def isEmpty(string: str) -> bool: ...
    @staticmethod
    def reverse(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    @staticmethod
    def writeFile(byteArray: typing.Union[typing.List[typing.MutableSequence[int]], jpype.JArray], string: str) -> None: ...
    class EntryType(java.lang.Enum['ChmCommons.EntryType']):
        UNCOMPRESSED: typing.ClassVar['ChmCommons.EntryType'] = ...
        COMPRESSED: typing.ClassVar['ChmCommons.EntryType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ChmCommons.EntryType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ChmCommons.EntryType']: ...
    class IntelState(java.lang.Enum['ChmCommons.IntelState']):
        STARTED: typing.ClassVar['ChmCommons.IntelState'] = ...
        NOT_STARTED: typing.ClassVar['ChmCommons.IntelState'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ChmCommons.IntelState': ...
        @staticmethod
        def values() -> typing.MutableSequence['ChmCommons.IntelState']: ...
    class LzxState(java.lang.Enum['ChmCommons.LzxState']):
        STARTED_DECODING: typing.ClassVar['ChmCommons.LzxState'] = ...
        NOT_STARTED_DECODING: typing.ClassVar['ChmCommons.LzxState'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ChmCommons.LzxState': ...
        @staticmethod
        def values() -> typing.MutableSequence['ChmCommons.LzxState']: ...

class ChmConstants:
    DEFAULT_CHARSET: typing.ClassVar[str] = ...
    ITSF: typing.ClassVar[str] = ...
    ITSP: typing.ClassVar[str] = ...
    PMGL: typing.ClassVar[str] = ...
    LZXC: typing.ClassVar[str] = ...
    CHM_PMGI_MARKER: typing.ClassVar[str] = ...
    BYTE_ARRAY_LENGHT: typing.ClassVar[int] = ...
    CHM_ITSF_V2_LEN: typing.ClassVar[int] = ...
    CHM_ITSF_V3_LEN: typing.ClassVar[int] = ...
    CHM_ITSP_V1_LEN: typing.ClassVar[int] = ...
    CHM_PMGL_LEN: typing.ClassVar[int] = ...
    CHM_PMGI_LEN: typing.ClassVar[int] = ...
    CHM_LZXC_RESETTABLE_V1_LEN: typing.ClassVar[int] = ...
    CHM_LZXC_MIN_LEN: typing.ClassVar[int] = ...
    CHM_LZXC_V2_LEN: typing.ClassVar[int] = ...
    CHM_SIGNATURE_LEN: typing.ClassVar[int] = ...
    CHM_VER_2: typing.ClassVar[int] = ...
    CHM_VER_3: typing.ClassVar[int] = ...
    CHM_VER_1: typing.ClassVar[int] = ...
    CHM_WINDOW_SIZE_BLOCK: typing.ClassVar[int] = ...
    START_PMGL: typing.ClassVar[int] = ...
    CONTROL_DATA: typing.ClassVar[str] = ...
    RESET_TABLE: typing.ClassVar[str] = ...
    CONTENT: typing.ClassVar[str] = ...
    LZX_MIN_MATCH: typing.ClassVar[int] = ...
    LZX_MAX_MATCH: typing.ClassVar[int] = ...
    LZX_NUM_CHARS: typing.ClassVar[int] = ...
    LZX_BLOCKTYPE_INVALID: typing.ClassVar[int] = ...
    LZX_BLOCKTYPE_VERBATIM: typing.ClassVar[int] = ...
    LZX_BLOCKTYPE_ALIGNED: typing.ClassVar[int] = ...
    LZX_BLOCKTYPE_UNCOMPRESSED: typing.ClassVar[int] = ...
    LZX_PRETREE_NUM_ELEMENTS_BITS: typing.ClassVar[int] = ...
    LZX_PRETREE_NUM_ELEMENTS: typing.ClassVar[int] = ...
    LZX_ALIGNED_NUM_ELEMENTS: typing.ClassVar[int] = ...
    LZX_NUM_PRIMARY_LENGTHS: typing.ClassVar[int] = ...
    LZX_NUM_SECONDARY_LENGTHS: typing.ClassVar[int] = ...
    LZX_PRETREE_MAXSYMBOLS: typing.ClassVar[int] = ...
    LZX_PRETREE_TABLEBITS: typing.ClassVar[int] = ...
    LZX_MAINTREE_MAXSYMBOLS: typing.ClassVar[int] = ...
    LZX_MAIN_MAXSYMBOLS: typing.ClassVar[int] = ...
    LZX_MAINTREE_TABLEBITS: typing.ClassVar[int] = ...
    LZX_LENGTH_MAXSYMBOLS: typing.ClassVar[int] = ...
    LZX_LENGTH_TABLEBITS: typing.ClassVar[int] = ...
    LZX_ALIGNED_MAXSYMBOLS: typing.ClassVar[int] = ...
    LZX_ALIGNED_TABLEBITS: typing.ClassVar[int] = ...
    LZX_LENTABLE_SAFETY: typing.ClassVar[int] = ...
    EXTRA_BITS: typing.ClassVar[typing.MutableSequence[int]] = ...
    POSITION_BASE: typing.ClassVar[typing.MutableSequence[int]] = ...

class ChmDirectoryListingSet:
    def __init__(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmItsfHeader: 'ChmItsfHeader', chmItspHeader: 'ChmItspHeader'): ...
    def getControlDataIndex(self) -> int: ...
    def getDataOffset(self) -> int: ...
    def getDirectoryListingEntryList(self) -> java.util.List['DirectoryListingEntry']: ...
    def getResetTableIndex(self) -> int: ...
    def setDirectoryListingEntryList(self, list: java.util.List['DirectoryListingEntry']) -> None: ...
    @staticmethod
    def startsWith(byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], string: str) -> bool: ...
    def toString(self) -> str: ...

class ChmExtractor:
    def __init__(self, inputStream: java.io.InputStream): ...
    def enumerateChm(self) -> java.util.List[str]: ...
    def extractChmEntry(self, directoryListingEntry: 'DirectoryListingEntry') -> typing.MutableSequence[int]: ...
    def getChmDirList(self) -> ChmDirectoryListingSet: ...

class ChmLzxBlock:
    def __init__(self, int: int, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], long: int, chmLzxBlock: 'ChmLzxBlock'): ...
    def getBlockNumber(self) -> int: ...
    @typing.overload
    def getContent(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getContent(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getContent(self, int: int, int2: int) -> typing.MutableSequence[int]: ...
    def getState(self) -> 'ChmLzxState': ...

class ChmLzxState(java.lang.Cloneable):
    def __init__(self, int: int): ...
    def clone(self) -> 'ChmLzxState': ...
    def getBlockType(self) -> int: ...
    def getLengthTreeLengtsTable(self) -> typing.MutableSequence[int]: ...
    def getMainTreeLengtsTable(self) -> typing.MutableSequence[int]: ...
    def setLengthTreeLengtsTable(self, shortArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setMainTreeLengtsTable(self, shortArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def toString(self) -> str: ...

class ChmParser(org.apache.tika.parser.Parser):
    def __init__(self): ...
    def getSupportedTypes(self, parseContext: org.apache.tika.parser.ParseContext) -> java.util.Set[org.apache.tika.mime.MediaType]: ...
    def parse(self, inputStream: java.io.InputStream, contentHandler: org.xml.sax.ContentHandler, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext) -> None: ...

class ChmParsingException(org.apache.tika.exception.TikaException):
    def __init__(self, string: str): ...

class ChmSection:
    @typing.overload
    def __init__(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]): ...
    @typing.overload
    def __init__(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], byteArray2: typing.Union[typing.List[int], jpype.JArray, bytes]): ...
    def checkBit(self, int: int) -> int: ...
    def getBigInteger(self, int: int) -> java.math.BigInteger: ...
    def getByte(self) -> int: ...
    def getData(self) -> typing.MutableSequence[int]: ...
    def getEncint(self) -> java.math.BigInteger: ...
    def getLeft(self) -> int: ...
    def getPrevContent(self) -> typing.MutableSequence[int]: ...
    def getSwath(self) -> int: ...
    def getSyncBits(self, int: int) -> int: ...
    def getTotal(self) -> int: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def peekBits(self, int: int) -> int: ...
    def reverseByteOrder(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.MutableSequence[int]: ...
    def setSwath(self, int: int) -> None: ...
    def setTotal(self, int: int) -> None: ...
    def stringToAsciiBytes(self, string: str) -> typing.MutableSequence[int]: ...
    def unmarshalBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def unmarshalUByte(self) -> int: ...
    def unmarshalUtfChar(self) -> str: ...

class ChmWrapper:
    def __init__(self): ...

class DirectoryListingEntry:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, string: str, entryType: ChmCommons.EntryType, int2: int, int3: int): ...
    def getEntryType(self) -> ChmCommons.EntryType: ...
    def getLength(self) -> int: ...
    def getName(self) -> str: ...
    def getNameLength(self) -> int: ...
    def getOffset(self) -> int: ...
    def toString(self) -> str: ...

class ChmItsfHeader(ChmAccessor['ChmItsfHeader']):
    def __init__(self): ...
    def getDataOffset(self) -> int: ...
    def getDirLen(self) -> int: ...
    def getDirOffset(self) -> int: ...
    def getDir_uuid(self) -> typing.MutableSequence[int]: ...
    def getHeaderLen(self) -> int: ...
    def getLangId(self) -> int: ...
    def getLastModified(self) -> int: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def getStream_uuid(self) -> typing.MutableSequence[int]: ...
    def getUnknownLen(self) -> int: ...
    def getUnknownOffset(self) -> int: ...
    def getUnknown_000c(self) -> int: ...
    def getVersion(self) -> int: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmItsfHeader: 'ChmItsfHeader') -> None: ...
    def toString(self) -> str: ...

class ChmItspHeader(ChmAccessor['ChmItspHeader']):
    def __init__(self): ...
    def getBlock_len(self) -> int: ...
    def getBlockidx_intvl(self) -> int: ...
    def getHeader_len(self) -> int: ...
    def getIndex_depth(self) -> int: ...
    def getIndex_head(self) -> int: ...
    def getIndex_root(self) -> int: ...
    def getLang_id(self) -> int: ...
    def getNum_blocks(self) -> int: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def getSystem_uuid(self) -> typing.MutableSequence[int]: ...
    def getUnknown_000c(self) -> int: ...
    def getUnknown_0024(self) -> int: ...
    def getUnknown_002c(self) -> int: ...
    def getUnknown_0044(self) -> typing.MutableSequence[int]: ...
    def getVersion(self) -> int: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmItspHeader: 'ChmItspHeader') -> None: ...
    def toString(self) -> str: ...

class ChmLzxcControlData(ChmAccessor['ChmLzxcControlData']):
    def __init__(self): ...
    def getResetInterval(self) -> int: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def getSize(self) -> int: ...
    def getUnknown_18(self) -> int: ...
    def getVersion(self) -> int: ...
    def getWindowSize(self) -> int: ...
    def getWindowsPerReset(self) -> int: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmLzxcControlData: 'ChmLzxcControlData') -> None: ...
    def toString(self) -> str: ...

class ChmLzxcResetTable(ChmAccessor['ChmLzxcResetTable']):
    def __init__(self): ...
    def getBlockAddress(self) -> typing.MutableSequence[int]: ...
    def getBlockCount(self) -> int: ...
    def getBlockLen(self) -> int: ...
    def getCompressedLen(self) -> int: ...
    def getTableOffset(self) -> int: ...
    def getUncompressedLen(self) -> int: ...
    def getUnknown(self) -> int: ...
    def getVersion(self) -> int: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmLzxcResetTable: 'ChmLzxcResetTable') -> None: ...
    def setBlockAddress(self, longArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setBlockCount(self, long: int) -> None: ...
    def setBlockLlen(self, long: int) -> None: ...
    def setCompressedLen(self, long: int) -> None: ...
    def setTableOffset(self, long: int) -> None: ...
    def setUncompressedLen(self, long: int) -> None: ...
    def setUnknown(self, long: int) -> None: ...
    def setVersion(self, long: int) -> None: ...
    def toString(self) -> str: ...

class ChmPmgiHeader(ChmAccessor['ChmPmgiHeader']):
    def __init__(self): ...
    def getFreeSpace(self) -> int: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmPmgiHeader: 'ChmPmgiHeader') -> None: ...
    def toString(self) -> str: ...

class ChmPmglHeader(ChmAccessor['ChmPmglHeader']):
    def __init__(self): ...
    def getBlockNext(self) -> int: ...
    def getBlockPrev(self) -> int: ...
    def getFreeSpace(self) -> int: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def getUnknown0008(self) -> int: ...
    def parse(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], chmPmglHeader: 'ChmPmglHeader') -> None: ...
    def setFreeSpace(self, long: int) -> None: ...
    def toString(self) -> str: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.parser.microsoft.chm")``.

    ChmAccessor: typing.Type[ChmAccessor]
    ChmAssert: typing.Type[ChmAssert]
    ChmBlockInfo: typing.Type[ChmBlockInfo]
    ChmCommons: typing.Type[ChmCommons]
    ChmConstants: typing.Type[ChmConstants]
    ChmDirectoryListingSet: typing.Type[ChmDirectoryListingSet]
    ChmExtractor: typing.Type[ChmExtractor]
    ChmItsfHeader: typing.Type[ChmItsfHeader]
    ChmItspHeader: typing.Type[ChmItspHeader]
    ChmLzxBlock: typing.Type[ChmLzxBlock]
    ChmLzxState: typing.Type[ChmLzxState]
    ChmLzxcControlData: typing.Type[ChmLzxcControlData]
    ChmLzxcResetTable: typing.Type[ChmLzxcResetTable]
    ChmParser: typing.Type[ChmParser]
    ChmParsingException: typing.Type[ChmParsingException]
    ChmPmgiHeader: typing.Type[ChmPmgiHeader]
    ChmPmglHeader: typing.Type[ChmPmglHeader]
    ChmSection: typing.Type[ChmSection]
    ChmWrapper: typing.Type[ChmWrapper]
    DirectoryListingEntry: typing.Type[DirectoryListingEntry]
