
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.nio.charset
import java.nio.file
import java.util
import java.util.concurrent
import java.util.regex
import jpype
import jpype.protocol
import org.apache.tika.batch
import org.apache.tika.batch.fs.builders
import org.apache.tika.batch.fs.strawman
import org.apache.tika.config
import org.apache.tika.extractor
import org.apache.tika.metadata
import org.apache.tika.metadata.filter
import org.apache.tika.parser
import org.apache.tika.sax
import typing



class AbstractFSConsumer(org.apache.tika.batch.FileResourceConsumer):
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource]): ...

class FSBatchProcessCLI:
    FINISHED_STRING: typing.ClassVar[str] = ...
    def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def usage(self) -> None: ...

class FSConsumersManager(org.apache.tika.batch.ConsumersManager):
    def __init__(self, list: java.util.List[org.apache.tika.batch.FileResourceConsumer]): ...
    def init(self) -> None: ...
    def shutdown(self) -> None: ...

class FSDirectoryCrawler(org.apache.tika.batch.FileResourceCrawler):
    @typing.overload
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], int: int, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], path2: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], cRAWL_ORDER: 'FSDirectoryCrawler.CRAWL_ORDER'): ...
    @typing.overload
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], int: int, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], cRAWL_ORDER: 'FSDirectoryCrawler.CRAWL_ORDER'): ...
    def handleFirstFileInDirectory(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]) -> None: ...
    def start(self) -> None: ...
    class CRAWL_ORDER(java.lang.Enum['FSDirectoryCrawler.CRAWL_ORDER']):
        SORTED: typing.ClassVar['FSDirectoryCrawler.CRAWL_ORDER'] = ...
        RANDOM: typing.ClassVar['FSDirectoryCrawler.CRAWL_ORDER'] = ...
        OS_ORDER: typing.ClassVar['FSDirectoryCrawler.CRAWL_ORDER'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'FSDirectoryCrawler.CRAWL_ORDER': ...
        @staticmethod
        def values() -> typing.MutableSequence['FSDirectoryCrawler.CRAWL_ORDER']: ...

class FSDocumentSelector(org.apache.tika.extractor.DocumentSelector):
    def __init__(self, pattern: java.util.regex.Pattern, pattern2: java.util.regex.Pattern, long: int, long2: int): ...
    def select(self, metadata: org.apache.tika.metadata.Metadata) -> bool: ...

class FSFileResource(org.apache.tika.batch.FileResource):
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], path2: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]): ...
    def getMetadata(self) -> org.apache.tika.metadata.Metadata: ...
    def getResourceId(self) -> str: ...
    def openInputStream(self) -> java.io.InputStream: ...

class FSListCrawler(org.apache.tika.batch.FileResourceCrawler):
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], int: int, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], path2: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], charset: java.nio.charset.Charset): ...
    def start(self) -> None: ...

class FSOutputStreamFactory(org.apache.tika.batch.OutputStreamFactory):
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], hANDLE_EXISTING: 'FSUtil.HANDLE_EXISTING', cOMPRESSION: 'FSOutputStreamFactory.COMPRESSION', string: str): ...
    def getOutputStream(self, metadata: org.apache.tika.metadata.Metadata) -> java.io.OutputStream: ...
    class COMPRESSION(java.lang.Enum['FSOutputStreamFactory.COMPRESSION']):
        NONE: typing.ClassVar['FSOutputStreamFactory.COMPRESSION'] = ...
        BZIP2: typing.ClassVar['FSOutputStreamFactory.COMPRESSION'] = ...
        GZIP: typing.ClassVar['FSOutputStreamFactory.COMPRESSION'] = ...
        ZIP: typing.ClassVar['FSOutputStreamFactory.COMPRESSION'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'FSOutputStreamFactory.COMPRESSION': ...
        @staticmethod
        def values() -> typing.MutableSequence['FSOutputStreamFactory.COMPRESSION']: ...

class FSProperties:
    FS_REL_PATH: typing.ClassVar[org.apache.tika.metadata.Property] = ...
    def __init__(self): ...

class FSUtil:
    def __init__(self): ...
    @staticmethod
    def checkThisIsAncestorOfOrSameAsThat(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], file2: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> bool: ...
    @staticmethod
    def checkThisIsAncestorOfThat(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], file2: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> bool: ...
    @staticmethod
    def getOutputFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], string: str, hANDLE_EXISTING: 'FSUtil.HANDLE_EXISTING', string2: str) -> java.io.File: ...
    @staticmethod
    def getOutputPath(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], string: str, hANDLE_EXISTING: 'FSUtil.HANDLE_EXISTING', string2: str) -> java.nio.file.Path: ...
    @staticmethod
    def resolveRelative(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], string: str) -> java.nio.file.Path: ...
    class HANDLE_EXISTING(java.lang.Enum['FSUtil.HANDLE_EXISTING']):
        OVERWRITE: typing.ClassVar['FSUtil.HANDLE_EXISTING'] = ...
        RENAME: typing.ClassVar['FSUtil.HANDLE_EXISTING'] = ...
        SKIP: typing.ClassVar['FSUtil.HANDLE_EXISTING'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'FSUtil.HANDLE_EXISTING': ...
        @staticmethod
        def values() -> typing.MutableSequence['FSUtil.HANDLE_EXISTING']: ...

class BasicTikaFSConsumer(AbstractFSConsumer):
    @typing.overload
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], parserFactory: org.apache.tika.batch.ParserFactory, contentHandlerFactory: org.apache.tika.sax.ContentHandlerFactory, outputStreamFactory: typing.Union[org.apache.tika.batch.OutputStreamFactory, typing.Callable], tikaConfig: org.apache.tika.config.TikaConfig): ...
    @typing.overload
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], parser: org.apache.tika.parser.Parser, contentHandlerFactory: org.apache.tika.sax.ContentHandlerFactory, outputStreamFactory: typing.Union[org.apache.tika.batch.OutputStreamFactory, typing.Callable]): ...
    def getOutputEncoding(self) -> java.nio.charset.Charset: ...
    def processFileResource(self, fileResource: org.apache.tika.batch.FileResource) -> bool: ...
    def setOutputEncoding(self, charset: java.nio.charset.Charset) -> None: ...

class RecursiveParserWrapperFSConsumer(AbstractFSConsumer):
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], parser: org.apache.tika.parser.Parser, contentHandlerFactory: org.apache.tika.sax.ContentHandlerFactory, outputStreamFactory: typing.Union[org.apache.tika.batch.OutputStreamFactory, typing.Callable], metadataFilter: org.apache.tika.metadata.filter.MetadataFilter): ...
    def getOutputEncoding(self) -> str: ...
    def processFileResource(self, fileResource: org.apache.tika.batch.FileResource) -> bool: ...
    def setOutputEncoding(self, string: str) -> None: ...

class StreamOutRPWFSConsumer(AbstractFSConsumer):
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[org.apache.tika.batch.FileResource], parser: org.apache.tika.parser.Parser, contentHandlerFactory: org.apache.tika.sax.ContentHandlerFactory, outputStreamFactory: typing.Union[org.apache.tika.batch.OutputStreamFactory, typing.Callable], metadataFilter: org.apache.tika.metadata.filter.MetadataFilter): ...
    def getOutputEncoding(self) -> str: ...
    def processFileResource(self, fileResource: org.apache.tika.batch.FileResource) -> bool: ...
    def setOutputEncoding(self, string: str) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.batch.fs")``.

    AbstractFSConsumer: typing.Type[AbstractFSConsumer]
    BasicTikaFSConsumer: typing.Type[BasicTikaFSConsumer]
    FSBatchProcessCLI: typing.Type[FSBatchProcessCLI]
    FSConsumersManager: typing.Type[FSConsumersManager]
    FSDirectoryCrawler: typing.Type[FSDirectoryCrawler]
    FSDocumentSelector: typing.Type[FSDocumentSelector]
    FSFileResource: typing.Type[FSFileResource]
    FSListCrawler: typing.Type[FSListCrawler]
    FSOutputStreamFactory: typing.Type[FSOutputStreamFactory]
    FSProperties: typing.Type[FSProperties]
    FSUtil: typing.Type[FSUtil]
    RecursiveParserWrapperFSConsumer: typing.Type[RecursiveParserWrapperFSConsumer]
    StreamOutRPWFSConsumer: typing.Type[StreamOutRPWFSConsumer]
    builders: org.apache.tika.batch.fs.builders.__module_protocol__
    strawman: org.apache.tika.batch.fs.strawman.__module_protocol__
