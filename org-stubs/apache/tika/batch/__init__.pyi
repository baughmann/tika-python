
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.concurrent
import jpype
import org.apache.tika.batch.builders
import org.apache.tika.batch.fs
import org.apache.tika.config
import org.apache.tika.extractor
import org.apache.tika.metadata
import org.apache.tika.parser
import typing



class BatchNoRestartError(java.lang.Error):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class BatchProcess(java.util.concurrent.Callable['ParallelFileProcessingResult']):
    def __init__(self, fileResourceCrawler: 'FileResourceCrawler', consumersManager: 'ConsumersManager', statusReporter: 'StatusReporter', interrupter: 'Interrupter'): ...
    def call(self) -> 'ParallelFileProcessingResult': ...
    def setMaxAliveTimeSeconds(self, int: int) -> None: ...
    def setPauseOnEarlyTerminationMillis(self, long: int) -> None: ...
    def setTimeoutCheckPulseMillis(self, long: int) -> None: ...
    def setTimeoutThresholdMillis(self, long: int) -> None: ...
    class BATCH_CONSTANTS(java.lang.Enum['BatchProcess.BATCH_CONSTANTS']):
        BATCH_PROCESS_EXCEEDED_MAX_ALIVE_TIME: typing.ClassVar['BatchProcess.BATCH_CONSTANTS'] = ...
        BATCH_PROCESS_FATAL_MUST_RESTART: typing.ClassVar['BatchProcess.BATCH_CONSTANTS'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'BatchProcess.BATCH_CONSTANTS': ...
        @staticmethod
        def values() -> typing.MutableSequence['BatchProcess.BATCH_CONSTANTS']: ...

class BatchProcessDriverCLI:
    PROCESS_RESTART_EXIT_CODE: typing.ClassVar[int] = ...
    PROCESS_NO_RESTART_EXIT_CODE: typing.ClassVar[int] = ...
    PROCESS_COMPLETED_SUCCESSFULLY: typing.ClassVar[int] = ...
    def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    def execute(self) -> None: ...
    def getNumRestarts(self) -> int: ...
    def isUserInterrupted(self) -> bool: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setRedirectForkedProcessToStdOut(self, boolean: bool) -> None: ...

class ConsumersManager:
    def __init__(self, list: java.util.List['FileResourceConsumer']): ...
    def getConsumers(self) -> java.util.List['FileResourceConsumer']: ...
    def getConsumersManagerMaxMillis(self) -> int: ...
    def init(self) -> None: ...
    def setConsumersManagerMaxMillis(self, long: int) -> None: ...
    def shutdown(self) -> None: ...

class FileResource:
    FILE_EXTENSION: typing.ClassVar[org.apache.tika.metadata.Property] = ...
    def getMetadata(self) -> org.apache.tika.metadata.Metadata: ...
    def getResourceId(self) -> str: ...
    def openInputStream(self) -> java.io.InputStream: ...

class FileResourceConsumer(java.util.concurrent.Callable['IFileProcessorFutureResult']):
    TIMED_OUT: typing.ClassVar[str] = ...
    OOM: typing.ClassVar[str] = ...
    IO_IS: typing.ClassVar[str] = ...
    IO_OS: typing.ClassVar[str] = ...
    PARSE_ERR: typing.ClassVar[str] = ...
    PARSE_EX: typing.ClassVar[str] = ...
    ELAPSED_MILLIS: typing.ClassVar[str] = ...
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[FileResource]): ...
    def call(self) -> 'IFileProcessorFutureResult': ...
    def checkForTimedOutMillis(self, long: int) -> 'FileStarted': ...
    def getCurrentFile(self) -> 'FileStarted': ...
    def getNumHandledExceptions(self) -> int: ...
    def getNumResourcesConsumed(self) -> int: ...
    def isStillActive(self) -> bool: ...
    def pleaseShutdown(self) -> None: ...
    def processFileResource(self, fileResource: FileResource) -> bool: ...

class FileResourceCrawler(java.util.concurrent.Callable['IFileProcessorFutureResult']):
    def __init__(self, arrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue[FileResource], int: int): ...
    def call(self) -> 'FileResourceCrawlerFutureResult': ...
    def getAdded(self) -> int: ...
    def getConsidered(self) -> int: ...
    def isActive(self) -> bool: ...
    def isQueueEmpty(self) -> bool: ...
    def setDocumentSelector(self, documentSelector: typing.Union[org.apache.tika.extractor.DocumentSelector, typing.Callable]) -> None: ...
    def setMaxConsecWaitInMillis(self, long: int) -> None: ...
    def setMaxFilesToAdd(self, int: int) -> None: ...
    def setMaxFilesToConsider(self, int: int) -> None: ...
    def shutDownNoPoison(self) -> None: ...
    def start(self) -> None: ...
    def wasTimedOut(self) -> bool: ...

class IFileProcessorFutureResult: ...

class Interrupter(java.util.concurrent.Callable[IFileProcessorFutureResult]):
    def __init__(self, long: int): ...
    def call(self) -> IFileProcessorFutureResult: ...

class OutputStreamFactory:
    def getOutputStream(self, metadata: org.apache.tika.metadata.Metadata) -> java.io.OutputStream: ...

class ParallelFileProcessingResult:
    def __init__(self, int: int, int2: int, int3: int, int4: int, double: float, int5: int, string: str): ...
    def getAdded(self) -> int: ...
    def getCauseForTermination(self) -> str: ...
    def getConsidered(self) -> int: ...
    def getConsumed(self) -> int: ...
    def getExitStatus(self) -> int: ...
    def getNumberHandledExceptions(self) -> int: ...
    def secondsElapsed(self) -> float: ...
    def toString(self) -> str: ...

class ParserFactory:
    def __init__(self): ...
    def getParser(self, tikaConfig: org.apache.tika.config.TikaConfig) -> org.apache.tika.parser.Parser: ...
    def isParseRecursively(self) -> bool: ...
    def setParseRecursively(self, boolean: bool) -> None: ...

class StatusReporter(java.util.concurrent.Callable[IFileProcessorFutureResult]):
    def __init__(self, fileResourceCrawler: FileResourceCrawler, consumersManager: ConsumersManager): ...
    def call(self) -> IFileProcessorFutureResult: ...
    def getRoughCountExceptions(self) -> int: ...
    def setIsShuttingDown(self, boolean: bool) -> None: ...
    def setSleepMillis(self, long: int) -> None: ...
    def setStaleThresholdMillis(self, long: int) -> None: ...

class FileResourceCrawlerFutureResult: ...

class FileStarted: ...

class AutoDetectParserFactory(ParserFactory):
    def __init__(self): ...
    def getParser(self, tikaConfig: org.apache.tika.config.TikaConfig) -> org.apache.tika.parser.Parser: ...

class DigestingAutoDetectParserFactory(ParserFactory):
    def __init__(self): ...
    def getParser(self, tikaConfig: org.apache.tika.config.TikaConfig) -> org.apache.tika.parser.Parser: ...
    def setDigester(self, digester: typing.Union[org.apache.tika.parser.DigestingParser.Digester, typing.Callable]) -> None: ...

class InterrupterFutureResult(IFileProcessorFutureResult):
    def __init__(self): ...

class StatusReporterFutureResult(IFileProcessorFutureResult):
    def __init__(self): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.batch")``.

    AutoDetectParserFactory: typing.Type[AutoDetectParserFactory]
    BatchNoRestartError: typing.Type[BatchNoRestartError]
    BatchProcess: typing.Type[BatchProcess]
    BatchProcessDriverCLI: typing.Type[BatchProcessDriverCLI]
    ConsumersManager: typing.Type[ConsumersManager]
    DigestingAutoDetectParserFactory: typing.Type[DigestingAutoDetectParserFactory]
    FileResource: typing.Type[FileResource]
    FileResourceConsumer: typing.Type[FileResourceConsumer]
    FileResourceCrawler: typing.Type[FileResourceCrawler]
    FileResourceCrawlerFutureResult: typing.Type[FileResourceCrawlerFutureResult]
    FileStarted: typing.Type[FileStarted]
    IFileProcessorFutureResult: typing.Type[IFileProcessorFutureResult]
    Interrupter: typing.Type[Interrupter]
    InterrupterFutureResult: typing.Type[InterrupterFutureResult]
    OutputStreamFactory: typing.Type[OutputStreamFactory]
    ParallelFileProcessingResult: typing.Type[ParallelFileProcessingResult]
    ParserFactory: typing.Type[ParserFactory]
    StatusReporter: typing.Type[StatusReporter]
    StatusReporterFutureResult: typing.Type[StatusReporterFutureResult]
    builders: org.apache.tika.batch.builders.__module_protocol__
    fs: org.apache.tika.batch.fs.__module_protocol__
