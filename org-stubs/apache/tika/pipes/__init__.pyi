
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.nio.file
import java.util
import jpype
import jpype.protocol
import org.apache.tika.config
import org.apache.tika.metadata
import org.apache.tika.parser
import org.apache.tika.pipes.async_
import org.apache.tika.pipes.emitter
import org.apache.tika.pipes.extractor
import org.apache.tika.pipes.fetcher
import org.apache.tika.pipes.pipesiterator
import org.apache.tika.sax
import typing



class FailedToStartClientException(java.lang.RuntimeException):
    def __init__(self, throwable: java.lang.Throwable): ...

class FetchEmitTuple(java.io.Serializable):
    DEFAULT_ON_PARSE_EXCEPTION: typing.ClassVar['FetchEmitTuple.ON_PARSE_EXCEPTION'] = ...
    @typing.overload
    def __init__(self, string: str, fetchKey: org.apache.tika.pipes.fetcher.FetchKey, emitKey: org.apache.tika.pipes.emitter.EmitKey): ...
    @typing.overload
    def __init__(self, string: str, fetchKey: org.apache.tika.pipes.fetcher.FetchKey, emitKey: org.apache.tika.pipes.emitter.EmitKey, metadata: org.apache.tika.metadata.Metadata): ...
    @typing.overload
    def __init__(self, string: str, fetchKey: org.apache.tika.pipes.fetcher.FetchKey, emitKey: org.apache.tika.pipes.emitter.EmitKey, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext): ...
    @typing.overload
    def __init__(self, string: str, fetchKey: org.apache.tika.pipes.fetcher.FetchKey, emitKey: org.apache.tika.pipes.emitter.EmitKey, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext, oN_PARSE_EXCEPTION: 'FetchEmitTuple.ON_PARSE_EXCEPTION'): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getEmitKey(self) -> org.apache.tika.pipes.emitter.EmitKey: ...
    def getFetchKey(self) -> org.apache.tika.pipes.fetcher.FetchKey: ...
    def getId(self) -> str: ...
    def getMetadata(self) -> org.apache.tika.metadata.Metadata: ...
    def getOnParseException(self) -> 'FetchEmitTuple.ON_PARSE_EXCEPTION': ...
    def getParseContext(self) -> org.apache.tika.parser.ParseContext: ...
    def hashCode(self) -> int: ...
    def setEmitKey(self, emitKey: org.apache.tika.pipes.emitter.EmitKey) -> None: ...
    def toString(self) -> str: ...
    class ON_PARSE_EXCEPTION(java.lang.Enum['FetchEmitTuple.ON_PARSE_EXCEPTION']):
        SKIP: typing.ClassVar['FetchEmitTuple.ON_PARSE_EXCEPTION'] = ...
        EMIT: typing.ClassVar['FetchEmitTuple.ON_PARSE_EXCEPTION'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'FetchEmitTuple.ON_PARSE_EXCEPTION': ...
        @staticmethod
        def values() -> typing.MutableSequence['FetchEmitTuple.ON_PARSE_EXCEPTION']: ...

class HandlerConfig(java.io.Serializable):
    DEFAULT_HANDLER_CONFIG: typing.ClassVar['HandlerConfig'] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, hANDLER_TYPE: org.apache.tika.sax.BasicContentHandlerFactory.HANDLER_TYPE, pARSE_MODE: 'HandlerConfig.PARSE_MODE', int: int, int2: int, boolean: bool): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getMaxEmbeddedResources(self) -> int: ...
    def getParseMode(self) -> 'HandlerConfig.PARSE_MODE': ...
    def getType(self) -> org.apache.tika.sax.BasicContentHandlerFactory.HANDLER_TYPE: ...
    def getWriteLimit(self) -> int: ...
    def hashCode(self) -> int: ...
    def isThrowOnWriteLimitReached(self) -> bool: ...
    def setMaxEmbeddedResources(self, int: int) -> None: ...
    @typing.overload
    def setParseMode(self, string: str) -> None: ...
    @typing.overload
    def setParseMode(self, pARSE_MODE: 'HandlerConfig.PARSE_MODE') -> None: ...
    def setThrowOnWriteLimitReached(self, boolean: bool) -> None: ...
    @typing.overload
    def setType(self, string: str) -> None: ...
    @typing.overload
    def setType(self, hANDLER_TYPE: org.apache.tika.sax.BasicContentHandlerFactory.HANDLER_TYPE) -> None: ...
    def setWriteLimit(self, int: int) -> None: ...
    def toString(self) -> str: ...
    class PARSE_MODE(java.lang.Enum['HandlerConfig.PARSE_MODE']):
        RMETA: typing.ClassVar['HandlerConfig.PARSE_MODE'] = ...
        CONCATENATE: typing.ClassVar['HandlerConfig.PARSE_MODE'] = ...
        @staticmethod
        def parseMode(string: str) -> 'HandlerConfig.PARSE_MODE': ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'HandlerConfig.PARSE_MODE': ...
        @staticmethod
        def values() -> typing.MutableSequence['HandlerConfig.PARSE_MODE']: ...

class PipesClient(java.io.Closeable):
    def __init__(self, pipesConfigBase: 'PipesConfigBase'): ...
    def close(self) -> None: ...
    def getFilesProcessed(self) -> int: ...
    def process(self, fetchEmitTuple: FetchEmitTuple) -> 'PipesResult': ...

class PipesConfigBase(org.apache.tika.config.ConfigBase):
    DEFAULT_MAX_FOR_EMIT_BATCH: typing.ClassVar[int] = ...
    DEFAULT_TIMEOUT_MILLIS: typing.ClassVar[int] = ...
    DEFAULT_STARTUP_TIMEOUT_MILLIS: typing.ClassVar[int] = ...
    DEFAULT_SHUTDOWN_CLIENT_AFTER_MILLS: typing.ClassVar[int] = ...
    DEFAULT_NUM_CLIENTS: typing.ClassVar[int] = ...
    DEFAULT_MAX_FILES_PROCESSED_PER_PROCESS: typing.ClassVar[int] = ...
    DEFAULT_STALE_FETCHER_TIMEOUT_SECONDS: typing.ClassVar[int] = ...
    DEFAULT_STALE_FETCHER_DELAY_SECONDS: typing.ClassVar[int] = ...
    def __init__(self): ...
    def getForkedJvmArgs(self) -> java.util.List[str]: ...
    def getJavaPath(self) -> str: ...
    def getMaxFilesProcessedPerProcess(self) -> int: ...
    def getMaxForEmitBatchBytes(self) -> int: ...
    def getNumClients(self) -> int: ...
    def getShutdownClientAfterMillis(self) -> int: ...
    def getSleepOnStartupTimeoutMillis(self) -> int: ...
    def getStaleFetcherDelaySeconds(self) -> int: ...
    def getStaleFetcherTimeoutSeconds(self) -> int: ...
    def getStartupTimeoutMillis(self) -> int: ...
    def getTikaConfig(self) -> java.nio.file.Path: ...
    def getTimeoutMillis(self) -> int: ...
    def setForkedJvmArgs(self, list: java.util.List[str]) -> None: ...
    def setJavaPath(self, string: str) -> None: ...
    def setMaxFilesProcessedPerProcess(self, int: int) -> None: ...
    def setMaxForEmitBatchBytes(self, long: int) -> None: ...
    def setNumClients(self, int: int) -> None: ...
    def setShutdownClientAfterMillis(self, long: int) -> None: ...
    def setSleepOnStartupTimeoutMillis(self, long: int) -> None: ...
    def setStaleFetcherDelaySeconds(self, int: int) -> None: ...
    def setStaleFetcherTimeoutSeconds(self, int: int) -> None: ...
    def setStartupTimeoutMillis(self, long: int) -> None: ...
    @typing.overload
    def setTikaConfig(self, string: str) -> None: ...
    @typing.overload
    def setTikaConfig(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]) -> None: ...
    def setTimeoutMillis(self, long: int) -> None: ...

class PipesException(java.lang.Exception):
    def __init__(self, throwable: java.lang.Throwable): ...

class PipesParser(java.io.Closeable):
    def __init__(self, pipesConfig: 'PipesConfig'): ...
    def close(self) -> None: ...
    def parse(self, fetchEmitTuple: FetchEmitTuple) -> 'PipesResult': ...

class PipesReporter(java.io.Closeable):
    NO_OP_REPORTER: typing.ClassVar['PipesReporter'] = ...
    def __init__(self): ...
    def close(self) -> None: ...
    @typing.overload
    def error(self, string: str) -> None: ...
    @typing.overload
    def error(self, throwable: java.lang.Throwable) -> None: ...
    @typing.overload
    def report(self, fetchEmitTuple: FetchEmitTuple, pipesResult: 'PipesResult', long: int) -> None: ...
    @typing.overload
    def report(self, totalCountResult: org.apache.tika.pipes.pipesiterator.TotalCountResult) -> None: ...
    def supportsTotalCount(self) -> bool: ...

class PipesResult:
    CLIENT_UNAVAILABLE_WITHIN_MS: typing.ClassVar['PipesResult'] = ...
    TIMEOUT: typing.ClassVar['PipesResult'] = ...
    OOM: typing.ClassVar['PipesResult'] = ...
    UNSPECIFIED_CRASH: typing.ClassVar['PipesResult'] = ...
    EMIT_SUCCESS: typing.ClassVar['PipesResult'] = ...
    INTERRUPTED_EXCEPTION: typing.ClassVar['PipesResult'] = ...
    EMPTY_OUTPUT: typing.ClassVar['PipesResult'] = ...
    @typing.overload
    def __init__(self, sTATUS: 'PipesResult.STATUS'): ...
    @typing.overload
    def __init__(self, sTATUS: 'PipesResult.STATUS', string: str): ...
    @typing.overload
    def __init__(self, sTATUS: 'PipesResult.STATUS', emitData: org.apache.tika.pipes.emitter.EmitData, boolean: bool): ...
    @typing.overload
    def __init__(self, emitData: org.apache.tika.pipes.emitter.EmitData): ...
    @typing.overload
    def __init__(self, emitData: org.apache.tika.pipes.emitter.EmitData, string: str): ...
    def getEmitData(self) -> org.apache.tika.pipes.emitter.EmitData: ...
    def getMessage(self) -> str: ...
    def getStatus(self) -> 'PipesResult.STATUS': ...
    def isIntermediate(self) -> bool: ...
    def toString(self) -> str: ...
    class STATUS(java.lang.Enum['PipesResult.STATUS']):
        CLIENT_UNAVAILABLE_WITHIN_MS: typing.ClassVar['PipesResult.STATUS'] = ...
        FETCHER_INITIALIZATION_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        FETCH_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        EMPTY_OUTPUT: typing.ClassVar['PipesResult.STATUS'] = ...
        PARSE_EXCEPTION_NO_EMIT: typing.ClassVar['PipesResult.STATUS'] = ...
        PARSE_EXCEPTION_EMIT: typing.ClassVar['PipesResult.STATUS'] = ...
        PARSE_SUCCESS: typing.ClassVar['PipesResult.STATUS'] = ...
        PARSE_SUCCESS_WITH_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        OOM: typing.ClassVar['PipesResult.STATUS'] = ...
        TIMEOUT: typing.ClassVar['PipesResult.STATUS'] = ...
        UNSPECIFIED_CRASH: typing.ClassVar['PipesResult.STATUS'] = ...
        NO_EMITTER_FOUND: typing.ClassVar['PipesResult.STATUS'] = ...
        EMIT_SUCCESS: typing.ClassVar['PipesResult.STATUS'] = ...
        EMIT_SUCCESS_PARSE_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        EMIT_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        INTERRUPTED_EXCEPTION: typing.ClassVar['PipesResult.STATUS'] = ...
        NO_FETCHER_FOUND: typing.ClassVar['PipesResult.STATUS'] = ...
        INTERMEDIATE_RESULT: typing.ClassVar['PipesResult.STATUS'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'PipesResult.STATUS': ...
        @staticmethod
        def values() -> typing.MutableSequence['PipesResult.STATUS']: ...

class PipesServer(java.lang.Runnable):
    TIMEOUT_EXIT_CODE: typing.ClassVar[int] = ...
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], inputStream: java.io.InputStream, printStream: java.io.PrintStream, long: int, long2: int, long3: int): ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def processRequests(self) -> None: ...
    def run(self) -> None: ...
    class STATUS(java.lang.Enum['PipesServer.STATUS']):
        READY: typing.ClassVar['PipesServer.STATUS'] = ...
        CALL: typing.ClassVar['PipesServer.STATUS'] = ...
        PING: typing.ClassVar['PipesServer.STATUS'] = ...
        FAILED_TO_START: typing.ClassVar['PipesServer.STATUS'] = ...
        FETCHER_NOT_FOUND: typing.ClassVar['PipesServer.STATUS'] = ...
        EMITTER_NOT_FOUND: typing.ClassVar['PipesServer.STATUS'] = ...
        FETCHER_INITIALIZATION_EXCEPTION: typing.ClassVar['PipesServer.STATUS'] = ...
        FETCH_EXCEPTION: typing.ClassVar['PipesServer.STATUS'] = ...
        PARSE_SUCCESS: typing.ClassVar['PipesServer.STATUS'] = ...
        PARSE_EXCEPTION_NO_EMIT: typing.ClassVar['PipesServer.STATUS'] = ...
        EMIT_SUCCESS: typing.ClassVar['PipesServer.STATUS'] = ...
        EMIT_SUCCESS_PARSE_EXCEPTION: typing.ClassVar['PipesServer.STATUS'] = ...
        EMIT_EXCEPTION: typing.ClassVar['PipesServer.STATUS'] = ...
        OOM: typing.ClassVar['PipesServer.STATUS'] = ...
        TIMEOUT: typing.ClassVar['PipesServer.STATUS'] = ...
        EMPTY_OUTPUT: typing.ClassVar['PipesServer.STATUS'] = ...
        INTERMEDIATE_RESULT: typing.ClassVar['PipesServer.STATUS'] = ...
        @staticmethod
        def lookup(int: int) -> 'PipesServer.STATUS': ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'PipesServer.STATUS': ...
        @staticmethod
        def values() -> typing.MutableSequence['PipesServer.STATUS']: ...

class CompositePipesReporter(PipesReporter, org.apache.tika.config.Initializable):
    def __init__(self): ...
    def addPipesReporter(self, pipesReporter: PipesReporter) -> None: ...
    def checkInitialization(self, initializableProblemHandler: typing.Union[org.apache.tika.config.InitializableProblemHandler, typing.Callable]) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def error(self, string: str) -> None: ...
    @typing.overload
    def error(self, throwable: java.lang.Throwable) -> None: ...
    def getPipesReporters(self) -> java.util.List[PipesReporter]: ...
    def initialize(self, map: typing.Union[java.util.Map[str, org.apache.tika.config.Param], typing.Mapping[str, org.apache.tika.config.Param]]) -> None: ...
    @typing.overload
    def report(self, fetchEmitTuple: FetchEmitTuple, pipesResult: PipesResult, long: int) -> None: ...
    @typing.overload
    def report(self, totalCountResult: org.apache.tika.pipes.pipesiterator.TotalCountResult) -> None: ...
    def supportsTotalCount(self) -> bool: ...

class LoggingPipesReporter(PipesReporter):
    def __init__(self): ...
    @typing.overload
    def error(self, string: str) -> None: ...
    @typing.overload
    def error(self, throwable: java.lang.Throwable) -> None: ...
    @typing.overload
    def report(self, fetchEmitTuple: FetchEmitTuple, pipesResult: PipesResult, long: int) -> None: ...
    @typing.overload
    def report(self, totalCountResult: org.apache.tika.pipes.pipesiterator.TotalCountResult) -> None: ...

class PipesConfig(PipesConfigBase):
    def getMaxWaitForClientMillis(self) -> int: ...
    @typing.overload
    @staticmethod
    def load(inputStream: java.io.InputStream) -> 'PipesConfig': ...
    @typing.overload
    @staticmethod
    def load(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]) -> 'PipesConfig': ...
    def setMaxWaitForClientMillis(self, long: int) -> None: ...

class PipesReporterBase(PipesReporter, org.apache.tika.config.Initializable):
    def __init__(self): ...
    def accept(self, sTATUS: PipesResult.STATUS) -> bool: ...
    def checkInitialization(self, initializableProblemHandler: typing.Union[org.apache.tika.config.InitializableProblemHandler, typing.Callable]) -> None: ...
    def initialize(self, map: typing.Union[java.util.Map[str, org.apache.tika.config.Param], typing.Mapping[str, org.apache.tika.config.Param]]) -> None: ...
    def setExcludes(self, list: java.util.List[str]) -> None: ...
    def setIncludes(self, list: java.util.List[str]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.pipes")``.

    CompositePipesReporter: typing.Type[CompositePipesReporter]
    FailedToStartClientException: typing.Type[FailedToStartClientException]
    FetchEmitTuple: typing.Type[FetchEmitTuple]
    HandlerConfig: typing.Type[HandlerConfig]
    LoggingPipesReporter: typing.Type[LoggingPipesReporter]
    PipesClient: typing.Type[PipesClient]
    PipesConfig: typing.Type[PipesConfig]
    PipesConfigBase: typing.Type[PipesConfigBase]
    PipesException: typing.Type[PipesException]
    PipesParser: typing.Type[PipesParser]
    PipesReporter: typing.Type[PipesReporter]
    PipesReporterBase: typing.Type[PipesReporterBase]
    PipesResult: typing.Type[PipesResult]
    PipesServer: typing.Type[PipesServer]
    async_: org.apache.tika.pipes.async_.__module_protocol__
    emitter: org.apache.tika.pipes.emitter.__module_protocol__
    extractor: org.apache.tika.pipes.extractor.__module_protocol__
    fetcher: org.apache.tika.pipes.fetcher.__module_protocol__
    pipesiterator: org.apache.tika.pipes.pipesiterator.__module_protocol__
