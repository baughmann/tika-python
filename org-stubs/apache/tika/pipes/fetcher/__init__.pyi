
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.nio.file
import java.util
import jpype.protocol
import org.apache.tika.config
import org.apache.tika.exception
import org.apache.tika.metadata
import org.apache.tika.parser
import org.apache.tika.pipes.fetcher.config
import org.apache.tika.pipes.fetcher.fs
import org.apache.tika.pipes.fetcher.url
import typing



class FetchKey(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, long: int, long2: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getFetchKey(self) -> str: ...
    def getFetcherName(self) -> str: ...
    def getRangeEnd(self) -> int: ...
    def getRangeStart(self) -> int: ...
    def hasRange(self) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class Fetcher:
    def fetch(self, string: str, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext) -> java.io.InputStream: ...
    def getName(self) -> str: ...

class FetcherManager(org.apache.tika.config.ConfigBase):
    def __init__(self, list: java.util.List[Fetcher]): ...
    @typing.overload
    def getFetcher(self) -> Fetcher: ...
    @typing.overload
    def getFetcher(self, string: str) -> Fetcher: ...
    def getSupported(self) -> java.util.Set[str]: ...
    @staticmethod
    def load(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]) -> 'FetcherManager': ...

class FetcherStringException(org.apache.tika.exception.TikaException):
    def __init__(self, string: str): ...

class AbstractFetcher(Fetcher):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    def getName(self) -> str: ...
    def setName(self, string: str) -> None: ...

class EmptyFetcher(Fetcher):
    def __init__(self): ...
    def fetch(self, string: str, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext) -> java.io.InputStream: ...
    def getName(self) -> str: ...

class RangeFetcher(Fetcher):
    @typing.overload
    def fetch(self, string: str, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext) -> java.io.InputStream: ...
    @typing.overload
    def fetch(self, string: str, long: int, long2: int, metadata: org.apache.tika.metadata.Metadata, parseContext: org.apache.tika.parser.ParseContext) -> java.io.InputStream: ...
    @typing.overload
    def fetch(self, string: str, long: int, long2: int, metadata: org.apache.tika.metadata.Metadata) -> java.io.InputStream: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.apache.tika.pipes.fetcher")``.

    AbstractFetcher: typing.Type[AbstractFetcher]
    EmptyFetcher: typing.Type[EmptyFetcher]
    FetchKey: typing.Type[FetchKey]
    Fetcher: typing.Type[Fetcher]
    FetcherManager: typing.Type[FetcherManager]
    FetcherStringException: typing.Type[FetcherStringException]
    RangeFetcher: typing.Type[RangeFetcher]
    config: org.apache.tika.pipes.fetcher.config.__module_protocol__
    fs: org.apache.tika.pipes.fetcher.fs.__module_protocol__
    url: org.apache.tika.pipes.fetcher.url.__module_protocol__
